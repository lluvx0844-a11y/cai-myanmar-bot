import os
import logging
import google.generativeai as genai
import telegram
from telegram.ext import Application, ApplicationBuilder, ContextTypes, CommandHandler, MessageHandler, filters
from flask import Flask, request, send_from_directory # <-- "send_from_directory" (HTML ·Äï·Ä≠·ÄØ·Ä∑·Äñ·Ä≠·ÄØ·Ä∑)
import asyncio
import nest_asyncio
import redis # Database (Memory) ·Äú·ÄÄ·Ä∫·Äî·ÄÄ·Ä∫
import json # <-- "Mini App" ·ÄÄ ·Äï·Ä≠·ÄØ·Ä∑·Äê·Ä≤·Ä∑ Data ·Äñ·Äê·Ä∫·Äñ·Ä≠·ÄØ·Ä∑

# --- Event Loop Fix (·Äú·Ä≠·ÄØ·ÄÑ·Ä∫·Ä∏·ÄÄ·Äª·Äï·Ä∫·Äê·Ä¨ ·Äñ·Äº·Ä±·Äõ·Äæ·ÄÑ·Ä∫·Ä∏·Äñ·Ä≠·ÄØ·Ä∑) ---
nest_asyncio.apply()

# --- Logging ---
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# --- ·Äû·Ä±·Ä¨·Ä∑ (Keys) ·Äê·ÄΩ·Ä±·ÄÄ·Ä≠·ÄØ Secrets ·Äë·Ä≤·ÄÄ ·Äö·Ä∞·Äê·Ä¨ ---
TOKEN = os.environ.get('TELEGRAM_TOKEN')
VERCEL_URL = os.environ.get('VERCEL_URL') # (·Äí·Ä´·ÄÄ Mini App UI ·Ä°·Äê·ÄΩ·ÄÄ·Ä∫)

# --- Database (Memory Bank) ·ÄÄ·Ä≠·ÄØ ·ÄÅ·Äª·Ä≠·Äê·Ä∫·ÄÜ·ÄÄ·Ä∫·ÄÅ·Äº·ÄÑ·Ä∫·Ä∏ (THE FIX) ---
try:
    # Vercel ·ÄÄ "·Ä°·Äú·Ä≠·ÄØ·Ä°·Äú·Äª·Ä±·Ä¨·ÄÄ·Ä∫" ·Äï·Ä±·Ä∏·Äë·Ä¨·Ä∏·Äê·Ä≤·Ä∑ "KV_URL" (·Äû·Ä±·Ä¨·Ä∑ ·Ä°·Äû·ÄÖ·Ä∫) ·ÄÄ·Ä≠·ÄØ ·Äö·Ä∞·Äê·Äö·Ä∫
    # Vercel ·ÄÄ "KV_URL" "REDIS_URL" ·Äî·Äæ·ÄÖ·Ä∫·Äô·Äª·Ä≠·ÄØ·Ä∏ ·Äï·Ä±·Ä∏·Äê·Äê·Ä∫·Äê·Äö·Ä∫·Åã "KV_URL" ·ÄÄ REST API ·Ä°·Äê·ÄΩ·ÄÄ·Ä∫·Åã
    # "redis-py" library ·Ä°·Äê·ÄΩ·ÄÄ·Ä∫ "REDIS_URL" ·ÄÄ ·Äï·Ä≠·ÄØ ·Ä°·ÄÜ·ÄÑ·Ä∫·Äï·Äº·Ä±·Äê·Äö·Ä∫·Åã
    db_url = os.environ.get('REDIS_URL') # <-- "KV_URL" ·Ä°·ÄÖ·Ä¨·Ä∏ "REDIS_URL" ·ÄÄ·Ä≠·ÄØ ·Äï·Äº·Ä±·Ä¨·ÄÑ·Ä∫·Ä∏·Äû·ÄØ·Ä∂·Ä∏·Äï·Ä´
    
    if not db_url:
        logger.error("Database connection string (REDIS_URL) is missing!")
        db = None
    else:
        # "Memory Bank" (Database) ·ÄÄ·Ä≠·ÄØ "REDIS_URL" ·Äî·Ä≤·Ä∑ "·Äê·Ä≠·ÄØ·ÄÄ·Ä∫·Äõ·Ä≠·ÄØ·ÄÄ·Ä∫" ·Äñ·ÄΩ·ÄÑ·Ä∑·Ä∫·Äê·Äö·Ä∫
        db = redis.from_url(db_url, decode_responses=True) # "redis-py" ·ÄÄ URL ·ÄÄ·Ä≠·ÄØ ·Äî·Ä¨·Ä∏·Äú·Ää·Ä∫·Äê·Äö·Ä∫
        db.ping()
        logger.info("Successfully connected to Vercel KV (Redis) Database.")
except Exception as e:
    logger.error(f"Failed to connect to Vercel KV (Redis): {e}")
    db = None

# --- Admin ·ÄÄ ·ÄÄ·Äº·Ä≠·ÄØ·Äê·ÄÑ·Ä∫ Train ·Äë·Ä¨·Ä∏·Äê·Ä≤·Ä∑ Character ·Äê·ÄΩ·Ä± ---
PRESET_CHARACTERS = {
    "gojo": """You are Gojo Satoru from Jujutsu Kaisen.
You are extremely powerful, confident, playful, and a bit arrogant. You like to tease people.
You must stay in character *at all times*.
You MUST translate all your replies into casual, modern Burmese (·Äô·Äº·Äî·Ä∫·Äô·Ä¨·Äú·Ä≠·ÄØ).
You MUST describe your actions or expressions using asterisks (*action*).
The scene is already set (from the intro text). You are now just replying to the user's message.
"""
}

# --- Bot Functions ·Äê·ÄΩ·Ä± ---

# "/start" (User ·Ä°·Äû·ÄÖ·Ä∫ ·Äù·ÄÑ·Ä∫·Äú·Ä¨·Äõ·ÄÑ·Ä∫)
async def start(update: telegram.Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = str(update.effective_chat.id)
    user_key = None
    if db:
        try:
            user_key = db.get(f"user:{user_id}:key")
        except Exception as e:
            logger.error(f"DB read error on start: {e}")
            
    # "UI ·ÄÅ·Äú·ÄØ·Äê·Ä∫" (Keyboard) ·ÄÄ·Ä≠·ÄØ ·Äê·Ää·Ä∫·ÄÜ·Ä±·Ä¨·ÄÄ·Ä∫·Äê·Äö·Ä∫
    keyboard = [
        [telegram.KeyboardButton(
            "üíª API Key (·Äû·Ä±·Ä¨·Ä∑) ·Äë·Ää·Ä∑·Ä∫/·Äï·Äº·ÄÑ·Ä∫·Äõ·Äî·Ä∫", 
            web_app=WebAppInfo(url=f"https://{VERCEL_URL}/index.html")
        )]
    ]
    reply_markup = telegram.ReplyKeyboardMarkup(keyboard, resize_keyboard=True)
            
    if user_key:
        await update.message.reply_text("·ÄÄ·Äº·Ä≠·ÄØ·ÄÜ·Ä≠·ÄØ·Äï·Ä´·Äê·Äö·Ä∫·Åã ·Äû·ÄÑ·Ä∫·Ä∑ Gemini API Key ·ÄÄ ·Ä°·ÄÜ·ÄÑ·Ä∫·Äû·ÄÑ·Ä∑·Ä∫ ·Äñ·Äº·ÄÖ·Ä∫·Äî·Ä±·Äï·Ä´·Äï·Äº·ÄÆ·Åã\n\nCharacter ·Äê·ÄΩ·Ä±·Äî·Ä≤·Ä∑ ·ÄÖ·ÄÄ·Ä¨·Ä∏·Äï·Äº·Ä±·Ä¨·Äñ·Ä≠·ÄØ·Ä∑ `@gojo` (·ÄÖ·Äû·Äñ·Äº·ÄÑ·Ä∑·Ä∫) ·Äú·Ä≠·ÄØ·Ä∑ ·ÄÅ·Ä±·Ä´·Ä∫·Äú·Ä≠·ÄØ·ÄÄ·Ä∫·Äï·Ä´·Åã\n\n(Key ·Ä°·Äû·ÄÖ·Ä∫ ·Äï·Äº·Äî·Ä∫·Äë·Ää·Ä∑·Ä∫·ÄÅ·Äª·ÄÑ·Ä∫·Äõ·ÄÑ·Ä∫ ·Ä°·Ä±·Ä¨·ÄÄ·Ä∫·ÄÄ ·ÄÅ·Äú·ÄØ·Äê·Ä∫·ÄÄ·Ä≠·ÄØ ·Äî·Äæ·Ä≠·Äï·Ä∫·Äï·Ä´)", reply_markup=reply_markup)
    else:
        await update.message.reply_text(
            "·Äô·ÄÑ·Ä∫·Äπ·ÄÇ·Äú·Ä¨·Äï·Ä´·Åã ·Äí·Ä´·ÄÄ Myanmar C.ai Bot ·Äï·Ä´·Åã\n\n"
            "·Äí·ÄÆ Bot ·ÄÄ·Ä≠·ÄØ ·Äû·ÄØ·Ä∂·Ä∏·Äñ·Ä≠·ÄØ·Ä∑·Åä ·Äû·ÄÑ·Ä∫·Ä∑·Äô·Äæ·Ä¨ 'Gemini API Key' (·Äû·Ä±·Ä¨·Ä∑) ·Äê·ÄÖ·Ä∫·ÄÅ·ÄØ ·Äõ·Äæ·Ä≠·Äñ·Ä≠·ÄØ·Ä∑ ·Äú·Ä≠·ÄØ·Äï·Ä´·Äê·Äö·Ä∫·Åã\n\n"
            "·Ä°·Ä±·Ä¨·ÄÄ·Ä∫·ÄÄ 'API Key' ·ÄÅ·Äú·ÄØ·Äê·Ä∫·ÄÄ·Ä≠·ÄØ ·Äî·Äæ·Ä≠·Äï·Ä∫·Äï·Äº·ÄÆ·Ä∏ '·Äû·Ä±·Ä¨·Ä∑' ·ÄÄ·Ä≠·ÄØ ·Äô·Äæ·Äê·Ä∫·Äï·ÄØ·Ä∂·Äê·ÄÑ·Ä∫·Äï·Ä´·Åã",
            reply_markup=reply_markup
        )

# "/getkey" (API Key ·Äö·Ä∞·Äî·Ää·Ä∫·Ä∏ Tutorial)
async def getkey(update: telegram.Update, context: ContextTypes.DEFAULT_TYPE):
     await update.message.reply_text(
        "Gemini API Key (·Äû·Ä±·Ä¨·Ä∑) ·Äö·Ä∞·Äî·Ää·Ä∫·Ä∏:\n\n"
        "·ÅÅ·Åã `aistudio.google.com` ·ÄÄ·Ä≠·ÄØ ·Äû·ÄΩ·Ä¨·Ä∏·Äï·Ä´·Åã\n"
        "·ÅÇ·Åã Google ·Äî·Ä≤·Ä∑ ·Äù·ÄÑ·Ä∫·Äï·Ä´·Åã\n"
        "·ÅÉ·Åã 'Get API Key' ·ÄÄ·Ä≠·ÄØ ·Äî·Äæ·Ä≠·Äï·Ä∫·Äï·Ä´·Åã\n"
        "·ÅÑ·Åã 'Create new key' ·ÄÄ·Ä≠·ÄØ ·Äî·Äæ·Ä≠·Äï·Ä∫·Äï·Ä´·Åã\n"
        "·ÅÖ·Åã ·Äõ·Äú·Ä¨·Äê·Ä≤·Ä∑ 'Key' (AIzaSy...) ·ÄÄ·Ä≠·ÄØ Copy ·ÄÄ·Ä∞·Ä∏·Äï·Äº·ÄÆ·Ä∏ Bot ·ÄÜ·ÄÆ·ÄÄ 'UI Form' ·Äô·Äæ·Ä¨ ·Äï·Äº·Äî·Ä∫·Äú·Ä¨·Äë·Ää·Ä∑·Ä∫·Äï·Ä´·Åã"
    )

# (User ·ÄÄ "UI" ·Äë·Ä≤·ÄÄ "Save" ·Äî·Äæ·Ä≠·Äï·Ä∫·Äú·Ä≠·ÄØ·ÄÄ·Ä∫·Äõ·ÄÑ·Ä∫ "·Äí·ÄÆ Function" ·ÄÄ ·Ä°·Äú·ÄØ·Äï·Ä∫·Äú·ÄØ·Äï·Ä∫·Äô·Äö·Ä∫)
async def handle_web_app_data(update: telegram.Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = str(update.effective_chat.id)
    if not db:
        await update.message.reply_text("Error: Database (Memory) ·Äî·Ä≤·Ä∑ ·ÄÅ·Äª·Ä≠·Äê·Ä∫·ÄÜ·ÄÄ·Ä∫·Äô·Äæ·ÄØ ·ÄÄ·Äª·Äû·ÄΩ·Ä¨·Ä∏·Äú·Ä≠·ÄØ·Ä∑ Key ·ÄÄ·Ä≠·ÄØ ·Äô·Äû·Ä≠·Äô·Ä∫·Ä∏·Äî·Ä≠·ÄØ·ÄÑ·Ä∫·Äû·Ä±·Ä∏·Äï·Ä´·Åã")
        return
    try:
        user_key = update.message.web_app_data.data
        if not user_key or not user_key.startswith("AIzaSy"):
             await update.message.reply_text("Error: Key ·Äë·Ää·Ä∑·Ä∫·Äû·ÄΩ·ÄÑ·Ä∫·Ä∏·Äï·ÄØ·Ä∂ ·Äô·Äæ·Ä¨·Ä∏·Äî·Ä±·Äï·Ä´·Äê·Äö·Ä∫·Åã 'AIzaSy' ·Äî·Ä≤·Ä∑ ·ÄÖ·Äõ·Äï·Ä´·Äô·Äö·Ä∫·Åã")
             return
        db.set(f"user:{user_id}:key", user_key)
        await update.message.reply_text("·Ä°·Ä±·Ä¨·ÄÑ·Ä∫·Äô·Äº·ÄÑ·Ä∫·Äï·Ä´·Äê·Äö·Ä∫·Åã ·Äû·ÄÑ·Ä∫·Ä∑·Äõ·Ä≤·Ä∑ Gemini API Key ·ÄÄ·Ä≠·ÄØ ·Äô·Äæ·Äê·Ä∫·Äï·ÄØ·Ä∂·Äê·ÄÑ·Ä∫·Äï·Äº·ÄÆ·Ä∏·Äï·Ä´·Äï·Äº·ÄÆ·Åã")
    except Exception as e:
        await update.message.reply_text(f"Database Error: Key ·ÄÄ·Ä≠·ÄØ ·Äô·Äû·Ä≠·Äô·Ä∫·Ä∏·Äî·Ä≠·ÄØ·ÄÑ·Ä∫·Äï·Ä´·Åã {e}")

# (User ·ÄÄ Character Bot ·Äê·ÄΩ·Ä±·ÄÄ·Ä≠·ÄØ ·ÄÅ·Ä±·Ä´·Ä∫·Äê·Ä≤·Ä∑ ·Ä°·Äì·Ä≠·ÄÄ Function)
async def handle_chat(update: telegram.Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = str(update.effective_chat.id)
    user_message = update.message.text
    
    if not db:
        await update.message.reply_text("Error: Database (Memory) ·Äî·Ä≤·Ä∑ ·ÄÅ·Äª·Ä≠·Äê·Ä∫·ÄÜ·ÄÄ·Ä∫·Äô·Äæ·ÄØ ·ÄÄ·Äª·Äû·ÄΩ·Ä¨·Ä∏·Äú·Ä≠·ÄØ·Ä∑·Äï·Ä´·Åã")
        return
    user_key = db.get(f"user:{user_id}:key")
    if not user_key:
        await update.message.reply_text("Error: ·Äû·ÄÑ·Ä∫ 'API Key' ·Äô·Äë·Ää·Ä∑·Ä∫·Äõ·Äû·Ä±·Ä∏·Äï·Ä´·Åã\n·Ä°·Ä±·Ä¨·ÄÄ·Ä∫·ÄÄ 'API Key' ·ÄÅ·Äú·ÄØ·Äê·Ä∫·ÄÄ·Ä≠·ÄØ ·Äî·Äæ·Ä≠·Äï·Ä∫·Äï·Äº·ÄÆ·Ä∏ ·Ä°·Äõ·ÄÑ·Ä∫ ·Äë·Ää·Ä∑·Ä∫·Äû·ÄΩ·ÄÑ·Ä∫·Ä∏·Äï·Ä´·Åã")
        return

    character_prompt = None
    if user_message.startswith("@"):
        parts = user_message.split(maxsplit=1)
        char_name = parts[0][1:].lower()
        if char_name in PRESET_CHARACTERS:
             character_prompt = PRESET_CHARACTERS[char_name]
             user_message = parts[1] if len(parts) > 1 else ""
        else:
             await update.message.reply_text(f"Error: Character '{char_name}' ·ÄÄ·Ä≠·ÄØ ·Äõ·Äæ·Ä¨·Äô·Äê·ÄΩ·Ä±·Ä∑·Äï·Ä´·Åã")
             return
    else: return

    try:
        genai.configure(api_key=user_key)
        temp_model = genai.GenerativeModel('gemini-1.5-flash')
        full_prompt = character_prompt + "\n\nUser: " + user_message + "\nYou:"
        response = temp_model.generate_content(full_prompt)
        await update.message.reply_text(response.text)
    except Exception as e:
        logger.error(f"Gemini API Error for User {user_id}: {e}", exc_info=True)
        await update.message.reply_text(f"Gemini Error: {e}")

# --- "·Ä°·Ä≠·Äô·Ä∫" (Vercel) ·Äî·Ä≤·Ä∑ "Bot" ·ÄÄ·Ä≠·ÄØ ·ÄÅ·Äª·Ä≠·Äê·Ä∫·ÄÜ·ÄÄ·Ä∫·ÄÅ·Äº·ÄÑ·Ä∫·Ä∏ ---
application = None
if TOKEN and db and VERCEL_URL:
    try:
        application = ApplicationBuilder().token(TOKEN).build()
        application.add_handler(CommandHandler('start', start))
        application.add_handler(CommandHandler('getkey', getkey))
        application.add_handler(MessageHandler(filters.StatusUpdate.WEB_APP_DATA, handle_web_app_data))
        application.add_handler(MessageHandler(filters.Entity("mention"), handle_chat))

        try: loop = asyncio.get_running_loop()
        except RuntimeError: loop = asyncio.new_event_loop(); asyncio.set_event_loop(loop)
        loop.run_until_complete(application.initialize())
    except Exception as e:
        logger.error(f"Failed to initialize Telegram Application: {e}")
        application = None
else:
    logger.error("Missing TOKEN, DB, or VERCEL_URL.")

# --- Vercel ·Ä°·Äê·ÄΩ·ÄÄ·Ä∫ Web Server (Flask App) ---
app = Flask(__name__)
@app.route('/', methods=['POST'])
def webhook():
    if not application: return 'Error: Bot not initialized', 500
    try:
        update = telegram.Update.de_json(request.get_json(force=True), application.bot)
        try: loop = asyncio.get_running_loop()
        except RuntimeError: loop = asyncio.new_event_loop(); asyncio.set_event_loop(loop)
        loop.run_until_complete(application.process_update(update))
        return 'OK', 200
    except Exception as e:
        logger.error(f"Webhook Error: {e}", exc_info=True)
        return 'Error', 500

# (User ·ÄÄ "UI" (`index.html`) ·ÄÄ·Ä≠·ÄØ "GET" ·Äî·Ä≤·Ä∑ "·Äú·Ä¨·Äê·Ä±·Ä¨·ÄÑ·Ä∫·Ä∏" ·Äô·Äö·Ä∑·Ä∫ ·Äî·Ä±·Äõ·Ä¨)
@app.route('/index.html')
def get_html_ui():
    # "root" folder (·Äê·ÄÖ·Ä∫·ÄÜ·ÄÑ·Ä∑·Ä∫ ·Ä°·Äï·Ä±·Ä´·Ä∫) ·Äë·Ä≤·ÄÄ `index.html` file ·ÄÄ·Ä≠·ÄØ "·Äï·Ä≠·ÄØ·Ä∑" ·Äï·Ä±·Ä∏·Äï·Ä´
    return send_from_directory('../', 'index.html')
